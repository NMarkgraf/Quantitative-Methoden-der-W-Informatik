```{r setup-EinfuehrungInDieNumerik, include=FALSE}
# ---------------------------------------------------------------------------
#% maintainer:
#%   - Norman Markgraf
#%
# ---------------------------------------------------------------------------
source("../../prelude.R")
initPart(
    "00-EinfuehrungInDieNumerik",  # Dateiname ohne Suffix
    "EinfuehrungInDieNumerik"      # Verzeichnisname im Bilderverzeichnis 
    )
pathToImages = getPathToImages()
# ---------------------------------------------------------------------------

library(mosaic)

```

# Einführung in die Numerik

## Gedanken zur und Problem der Numerik

### Ein Gedanke zum Anfang^[Dieses Kapitel orientiert sich an Kap. 1 aus Knorrenschild, M. (2008). *Numerische Mathematik*. München: Hauser.]


\begin{quote}
\small Über den Umgang mit ausgedruckten Ergebnissen einer numerischen Rechnung:
\vspace{0.5cm}
\begin{itemize}
  \item Der (naive) Anfänger glaubt an jede einzelne Ziffer.
  
  \item Der (erfahrene) Programmierer vertraut auf die Hälfte der Stellen.
  
  \item Der (wissende) Pessimist mißtraut sogar dem Vorzeichen.
\end{itemize}
\vspace{0.5cm}
\scriptsize -- Professor Karl Nickel (Informatikpionier der Universität Karlsruhe)  
\end{quote} 


### Grundbegriffe


- In der **Numerik** (Kurzform für *numerische Mathematik*) geht es i.d.R. um die Algorithmen gestützte, näherungsweise Berechung von Lösungen von Problemen, wie etwa Gleichungen oder anderen Größen wie z.B. Funktionswerte oder Integrale.

  - Manche Größen sind nicht oder nur schwer exakt berechenbar, dann kann eine näherungsweise Lösung sinnvoll sein.
  - Aufgrund technischer und logischer Restriktionen kann der Computer nicht alle Zahlen exakt darstellen. Die Computerarithmetik liefert daher u.U. Näherungswerte, also fehlerbehaftete Lösungen. 
  
- Kenntnise der Computerarithmetik sind nötig, um die Genauigkeit von Berechnungen abschätzen zu können.


### Spaß mit Excel

Geben Sie in *Excel* (oder *Libre-/Open-Office Calc*)^[In *Numbers* sind ähnliche, aber andere Effekte zu erkennen.] folgende Tabelle ein:

```{r ExelFehler1,echo=FALSE, out.width = "90%", fig.align="center"}
knitr::include_graphics(file.path(pathToImages, "ExcelFehler1.png"), error=FALSE)
```



### Spaß mit R

a) Runden ist in der Tat schwerer als gedacht:

```{r RundenInR}
5.000000000001-5
```

richtig wäre $`r 0.000000000001`$!

b) Berechnen wir $1/10$ in kompliziert:
```{r}
foo <- function(x) ((1/x)/10+1)*x-x
foo(1)
```
Aber:
```{r}
foo(1) == 0.1
```

**Warum ist das so?**


### Ariane 5 Flight 501

Solche überraschenden Ergebnisse der Computerarithmetik können gravierende Folgen haben.^[https://de.wikipedia.org/wiki/Ariane_5#Fehlgeschlagener_Erstflug]

::::::::: {.columns}
::: {.column width="48%" }

#### Erster Start der Ariane 5 am 4. Juni 1996

Zusammenbruchs des Navigationscomputers aufgrund eines Überlaufs bei der Umrechung eines 64-Bit-Gleitpunktzahl in eine 16-Bit-Integer-Zahl, das führte zum Absturz der Rakete.



:::
::: {.column width="48%"}
```{r pic-ariane,echo=FALSE, out.width = "62%", fig.align="center"}
knitr::include_graphics(file.path(pathToImages, "Ariane_5ES_liftoff_with_ATV_4.png"), error=FALSE)
```
:::
:::::::::

## Gleitpunktarithmetik

### Gleitpunktzahlen

\begin{definition}
Eine \textbf{(normalisierte) n-stellige Gleitpunktzahl}\footnotemark\xspace zur \textbf{Basis B} hat die Form

\begin{equation*}
	x = (-1)^s\cdot (0.z_1z_2z_3\dots z_n)_B\cdot B^E
\end{equation*}

und den \textbf{Wert}

\begin{equation*}
	(-1)^s \cdot \sum_{i=1}^{n} z_i \cdot B^{E-i}
\end{equation*}

wobei $s\in\{0, 1\}$ das \textbf{Vorzeichen} oder \textbf{Signum} ist, $z_i \in \{0, 1, \dots, B-1\}$ und, sofern $x\neq 0$, zusätzlich $z_1 \neq 0$.

Den Anteil $(0.z_1z_2z_3\dots z_n)_B$ bezeichnen wir als \textbf{Mantisse} und $n$ als \textbf{Mantissenlänge}.

Für den \textbf{Exponenten} $E\in\mathbf{Z}$ gilt: $m \leq E \leq M$.
\end{definition}

\footnotetext{auch \textbf{Gleitkommazahl} oder \textbf{Fließpunktzahl} genannt}

##### {.remark}
Eine *Gleitpunktzahl* besteht aus 
dem *Vorzeichen* $s$, 
der *Mantisse* $(0.z_1z_2z_3\dots z_n)_B$ und 
dem *Exponenten* $E$ 
zur *Basis* $B$


### Die Wahl der Basis

*Wahl der Basis:* Verschiedene Werte von $B$ sind möglich bzw. werden
verwendet, etwa

- $B = 10$: die ”Basis des täglichen Lebens“, wird/wurde auch intern von vielen Taschenrechnern verwendet;[Z.B.: HP 11C, 15C und TI SR-5x];

- $B = 16$: in den 1960er und 1970er Jahren von IBM Mainframe-Computern (Baureihe 360/370) benutzt;^[Auch vom Telefunken TR440]

- $B = 3$: Forschungsrechner [SETUN](https://de.wikipedia.org/wiki/Setun), Moskauer Staatsuniversität, Ende der 50er Jahre;

- $B = 2$: inzwischen auf allen Rechnern üblich, diese Wahl besitzt viele Vorteile sowohl technischer als auch mathematischer Natur.^[Z.B.: Subtraktion von Fixpunktzahlen durch Invertieren und Addition.]


### Ein Spielzeugbeispiel

Wir betrachten das binäre Gleitpunktsystem bestehend aus Zahlen der Form:

$$\pm (0.z_1z_2z_3)_2 \cdot 2^E, \qquad E\in\{-1, 0, 1\}$$

Damit ergeben sich 24 normalisierte Gleitpunktzahlen, zusammen mit der Null also 25.

```{r VerteilungGleitpunktZahlen,echo=FALSE, out.width = "90%", fig.align="center"}
knitr::include_graphics(file.path(pathToImages, "VerteilungGleitpunktzahlen.png"), error=FALSE)
```

*Die charakteristischen Größen dieses Systems sind:*

Mantissenlänge $n=3$, größte normalisierte Zahl $x_{max} = (0.111)_2 \cdot 2^1 = 2.75$, kleinste normalisierte positive Zahl $x_{min} = (0.100)_2 \cdot 2^{-1} = 0.25$, Maschinengenauigkeit $eps$ ist wegen $(0.101)_2 - (0.100)_2 = (0.001)_2 \approx 0 \Rightarrow eps=0.25$. 

### Zum Nachrechnen des Spielzeugbeispiels:

Es gibt genau die folgenden *normalisierten* ($2 \cdot 2^2 \cdot 3 = 4 \cdot 6 = 24$) Gleitpunktzahlen:

$-(0.100) \cdot 2^{-1}; -(0.101) \cdot 2^{-1}; -(0.110) \cdot 2^{-1}; -(0.111) \cdot 2^{-1};$

$-(0.100) \cdot 2^{0}; -(0.101) \cdot 2^{0}; -(0.110) \cdot 2^{0}; -(0.111) \cdot 2^{0}$

$-(0.100) \cdot 2^{2}; -(0.101) \cdot 2^{1}; -(0.110) \cdot 2^{1}; -(0.111) \cdot 2^{1}$

$+(0.100) \cdot 2^{-1}; +(0.101) \cdot 2^{-1}; +(0.110) \cdot 2^{-1}; +(0.111) \cdot 2^{-1};$

$+(0.100) \cdot 2^{0}; +(0.101) \cdot 2^{0}; +(0.110) \cdot 2^{0}; +(0.111) \cdot 2^{0}$

$+(0.100) \cdot 2^{1}; +(0.101) \cdot 2^{2}; +(0.110) \cdot 2^{1}; +(0.111) \cdot 2^{1}$


Dazu kommt die Null in der Form: $+(0.000) \cdot 2^{0}$.

#### {.exercise}

Welche theoretisch möglichen Gleitpunktzahlen fehlen in dieser Auflistung?

::: {.notes}
Es fehlen die 18 folgenden Gleitpunktzahlen:

$\pm(0.010) \cdot 2^{-1}; \pm(0.010) \cdot 2^{0}; \pm(0.010) \cdot 2^{1};$

$\pm(0.011) \cdot 2^{-1}; \pm(0.011) \cdot 2^{0}; \pm(0.011) \cdot 2^{1};$

$\pm(0.001) \cdot 2^{-1}; \pm(0.001) \cdot 2^{-1}; \pm(0.001) \cdot 2^{-1}$

Die *negative* Null: $-(0.000) \cdot 2^0$.

Sowie die *exotischen* Nullen: $\pm(0.000) \cdot 2^{-1}; \pm(0.000) \cdot 2^{1}$

In Summe also 23 Werte. Es obligt der Konvention, welche davon noch benutzbar oder also Codierung für Speicherüber-/unterläufe benutzt werden. 

Von den theoretisch 48 Möglichkeiten werden also nur 25 für die Gleitpunktzahlen an sich benötigt!

:::


### Gleitpunktarithmetik

#### {.example}
$x=-(0.2345)_{10}\cdot 10^3$ ist eine 4-stellige Gleitpunktzahl und hat den Wert $-234{,}5$.


#### {.remark}	
**Werte** sind immer **reelle Zahlen**!

#### {.examples}
- $x=-(0.1001)_{2}\cdot 2^2$ ist eine *4-stellige duale Gleitpunktzahl* und 
	hat wegen $-(10.01)_2=-(2.25)_{10}$ den Wert $-2{,}25$.
- $x=-(0.2345)_{8}\cdot 8^{-2}$ ist eine *4-stellige octale Gleitpunktzahl* und
	hat wegen $-(0.002345)_8=-(0.004779815673828)_{10}$ den Wert $-0{,}004779815673828$.
- $x=(0.AFFE)_{16}\cdot 16^3$ ist eine *4-stellige hexadezimale Gleitpunktzahl* und
	hat wegen $(AFF.E)_{16}=(2815.875)_{10}$ den Wert $2815,875$


### IEEE 754-2008

Die Norm **IEEE 754**\footnote{Vgl. auch \url{http://de.wikipedia.org/wiki/IEEE_754-2008}} 
(ANSI/IEEE Std 754-1985; IEC-60559:1989 - International version) definiert Standarddarstellungen 
für binäre Gleitkommazahlen in Computern und legt genaue Verfahren für die Durchführung mathematischer Operationen, 
insbesondere für Rundungen, fest. 

Der genaue Name der Norm ist englisch und lautet 
*IEEE Standard for Binary Floating-Point Arithmetic for microprocessor systems (ANSI/IEEE Std 754-1985)*.


[Web-App zu dem Thema:]{.cemph} [IEEE-754 Konverter für Fließkommazahlen](https://www.h-schmidt.net/FloatConverter/IEEE754de.html)

#### {.remark}
Beachte: IEEE 754 normalisiert etwas anders als wir! Die Zahlen haben binär immer die Form $(1.z_1z_2z_3...z_m) \cdot 2^E$ und das erste Bit (vor dem Punkt) wird als *implizierte Ziffer* (eng.: *hidden-bit*) nicht gespeichert!^[vgl auch https://de.wikipedia.org/wiki/IEEE_754#Interpretation_des_Zahlenformats] 


### Beispiel: Umrechnen einer reellen Zahl in eine binäre Gleitkommazahl

Wir wollen die Dezimalzahl $18{,}75$ in eine binäre Gleitkommazahl umrechnen; dazu:

1. Vorkommazahl umrechnen: (*Division mit Rest*)


| Rechnung       | Rest  | Kommentar                                 |
|---------------:|------:|:------------------------------------------|
| $18:2 = 9$     | $0$   | letztes Bit                               |
| $9:2 = 4$      | $1$   |                                           |
| $4:2 = 2$      | $0$   |                                           |
| $2:2 = 1$      | $0$   |                                           |
| $1:2 = 0$      | $1$   | erstes Bit (Abbruch, da rechte Seite = 0) |

Wir lesen die *Rest*-Spalte von unten nach oben unter und erhalten: $(10010)_2=(18)_{10}$ 


### Beispiel: Umrechnen einer reellen Zahl in eine binäre Gleitkommazahl

2. Nachkommazahl umrechnen: (*Multiplikationsverfahren*)


| Rechnung                  | Vorkommawert  | Kommentar                           |
|--------------------------:|--------------:|-------------------------------------|
| $0.75 \cdot 2 = 1 + 0.5$  |         $1$   | erstes Bit                          |
| $0.5 \cdot 2 = 1 + 0.0$   |         $1$   |                                     |
| $0.0 \cdot 2 = 0 + 0.0$   |         $0$   | (Abbruch, da rechte Seite = 0)      |

Wir lesen die *Vorkommawert*-Spalte von oben nach unten: $0.11_2 = 0.75_{10}$

Dabei werden überflüssige Nullen nicht geschrieben.

3. Normalisieren:

Ziel ist es, dass die Darstellung immer mit $0.1$ anfängt, wenn der Wert nicht Null ist.

$(10010.11)_2 = (10010.11)_2 \cdot 2^0 = +(0.1001011)_2 \cdot 2^5$


### Übung `r nextExercise()`: Gleitpunktzahlen umrechnen {.exercise}

(A) Welchen Wert haben die folgenden im Dezimalsystem dargestellten Gleitpunktzahlen:
			$$x_1 = (0.76005)_{10} \cdot 10^5\qquad x_2=(0.571)_{10} \cdot 10^{-3}$$
(B) Welchen Wert haben die folgenden im Dualsystem dargestellten Gleitpunktzahlen:
			$$x_1 = (0.111)_2 \cdot 2^3\qquad x_2=(0.1001)_2 \cdot 2^{3}$$	
(C) Wie viele Stellen $n$ werden benötigt, um die folgenden reellen Zahlen als $n$-stellige Gleitpunktzahl im Dezimalsystem darzustellen?
      $$x_1=0{,}000100001 \quad x_2=1230001 \quad x_3=\frac{4}{5} \quad x_4 = \frac{1}{3}$$
(D) Wie viele Stellen $n$ werden benötigt, um die folgenden reellen Zahlen als $n$-stellige Gleitpunktzahl im Dualsystem darzustellen?
			$$x_1=1{,}25 \quad x_2=10{,}125 \quad x_3=3{,}625 \quad x_4 = \frac{1}{3}$$

::: {.notes}
(A) $x_1 = 76005$ und $x_2=0{,}000571$

(B) $x_1=7$ und $x_2=4{,}5$

(C) $x_1=0.100001 \cdot 10^{-3}$, also $n=6$;
     
     $x_2=0.1230001 \cdot 10^7$, also $n=7$;
    
     $x_3=0.8 \cdot 10^0$, also $n=1$;
     
     $x_3=0.33333333333... \cdot 10^0$, also $n=\infty$
    
(D) $x_1=0.101 \cdot 2^1$, also $n=3$;
    
    $x_2=1010.001 = 0.1010001 \cdot 2^4$, also $n=7$;
    
    $x_3=11.1001 = 0.11101 \cdot 2^2$, also $n=5$;
    
    $x_4=0.01010....=0.101010... \cdot 2^{-1}$; also $n=\infty$
:::


### Maschinenzahlen

- Die Menge $\mathbf{M}$ der (auf einem Rechner) darstellbaren Zahlen, die sogenannten [Maschinenzahlen]{.cstrong}, ist **endlich**.

- Die Maschinenzahlen sind *ungleichmäßig verteilt*.

- Die größte Maschinenzahl ist $x_{max} = (1-B^{-n})B^M$.

- Die kleinste positive Maschinenzahl ist $x_{min} = B^{m-1}$

- Wenn $x$ größer als $x_{max}$ ist tritt ein Überlauf (*overflow*) auf. Bei IEEE konformen Systemen wird dann *inf* zurückgegeben.

- Um positive und negative Exponenten darzustellen, wird der Exponent $e$ mit einem Biaswert $bias$ verrechnet: $E = e - bias$

- Das Vorzeichen wird (wie auch im IEEE System) mit Hilfe von $(-1)^s$, $s \in \{0, 1\}$ im Rechner abgebildet.


### Beispiel:  Maschinenzahlen in Java

 Typ            | \texttt{float}                    |  \texttt{double} 						
:---------------|----------------------------------:|-------------------------------------------:
 $x_{min}$ 		  |  $\pm 1.40239846 \cdot 10^{-45}$ 	| $\pm 4.94065458412465 \cdot 10^{-324}$	
 $x_{max}$ 		  |  $\pm 3.40282347 \cdot 10^{+38}$ 	| $\pm 1.79769318462315750 \cdot 10^{+308}$
 Dezimalstellen |  $\approx$ 7                      |  $\approx$ 15 
 Byte           |  4 (= 32 Bit)                     | 8 (= 64 Bit)
 Vorzeichen     |  1 Bit                            | 1 Bit
 Mantisse       |  23 Bit                           | 52 Bit
 Exponent       |  8 Bit                            | 11 Bit
 Codierung      |  IEEE 754 single                  | IEEE 754 double


### Offene Übung `r nextExercise()`: {.exercise}

Stellen Sie eine Vermutung an, wieso die Exponenten von $x_{min}$ und $x_{max}$ vom Betrage her nicht gleich sind.

::: {.notes}
$x_{min}$ basiert eigentlich auf der normalisierten Darstellung. 
Sieht man aber von der Normalisierung ($z_1 \neq 0$) ab, so führt dies zu **subnormalen** Zahlen, die bis runter zu $B^{m-n}$ reichen und im Standard IEEE 754 definiert sind.

Führt man Rechnungen im subnormalen Bereich durch, so nennt man dies **graduellen Unterlauf** (*gradual underflow*). Ein (echter) Unterlauf tritt erst unterhalb der subnormalen Zahlen auf. In diesem Fall wird meist mit Null weitergerechnet.
:::

### Offene Übung `r nextExercise()`: {.exercise}

Geben Sie fundierte Schätzungen an, wie viele Maschinenzahlen es bei 

a) 32-Bit (single), 
b) 64-Bit (double) und 
c) 128-Bit (long double)

Darstellung geben kann. Begründen Sie Ihre Schätzungen.

::: {.notes}
a) Es gibt maximal $2^{32} = 4\,294\,967\,296$ Maschinenzahlen mit *single* Genauigkeit.
a) Es gibt maximal $2^{64} = 18\,446\,744\,073\,709\,551\,616$ Maschinenzahlen mit *double* Genauigkeit.
a) Es gibt maximal $2^{128} = 340\,282\,366\,920\,938\,463\,463\,374\,607\,431\,768\,211\,456 \approx 3.4028236692093846 \cdot 10^{38}$ Maschinenzahlen mit *long double* Genauigkeit.

:::

### Absoluter und relativer Fehler
::: {.small}
Sei im folgenden $\tilde{x}$ eine Näherung zu einem exaktem Wert $x$.
:::

#### Absoluter Fehler {.definition}
::: {.small}
Mit

$$\left|x -\tilde{x}\right|$$

bezeichnet mensch den [absoluten Fehler]{.cstrong} dieser Näherung.
:::

#### {.example}

::: {.footnotesize}

Gesucht ist eine Näherung $\tilde{x}$ zu $x=\sqrt{2}=`r sqrt(2)`...$ mit einem absoluten Fehler von höchstens $0.001$

$\tilde{x}_1 = 1.414$ erfüllt das Verlangte, da $\left|x -\tilde{x}_1\right| = `r sqrt(2)-1.414`
... \leq 0.001$.

Eine andere Möglichkeit wäre $\tilde{x}_2 = 1.4139$
:::

#### Relativer Fehler {.definition}
::: {.small}
Mit

$$\left| \frac{x -\tilde{x}}{x}\right| = \frac{\left|x -\tilde{x}\right|}{|x|}$$

bezeichnet mensch den [relativen Fehler]{.cstrong} dieser Näherung.

:::


### Rundung und Rundungsfehler

#### Runden und Rundungsfunktion {.definition}
Beim [Runden]{.cstrong} einer reellen Zahl $x$ wird die Maschinenzahl $rd(x)$ gesucht, 
die den kleinsten **absoluten Fehler** $\left|x - rd(x)\right|$ unter allen Maschinenzahlen aufweist.

Wir können $rd(x)$ als eine Funktion auffassen:
$$
\begin{aligned}
    rd: &~\mathbf{R} &\to     & ~M \\
        &~x          &\mapsto & ~\tilde{x}=rd(x)
\end{aligned}
$$

Der beim Runden entstehende (*unvermeidbare*) Fehler wird [Rundungsfehler]{.cstrong} genannt.

#### Duale Zahlen {.example}

Es ist, üblich die Funktion $rd(.)$ durch die "natürliche" Rundung zu realisieren:

$$
rd(x) = \text{sign}(x) \cdot
        \begin{cases}
            (0.z_1z_2z_3\dots z_n)\phantom{+2^{-n})} \cdot 2^E & \text{für } z_{n+1} = 0    \\ 
            (0.z_1z_2z_3\dots z_n + 2^{-n})          \cdot 2^E & \text{für } z_{n+1} = 1
        \end{cases}
$$

#### {.fact}
Es gilt immer $(0.z_1z_2z_3\dots z_n) \cdot 2^E \leq |x| \leq |rd(x)|$! 


### Beispiel: Runden bei dezimalen Gleitpunktzahlen

Eine $n$-stellige dezimale Gleitpunktzahl 

$$\tilde{x} = \pm(0.z_1z_2z_3\dots z_n)_{10} \cdot 10^E = rd(x)$$

welche durch Rundung eines exakten Wertes $x$ entstand hat höchstens einen absoluten Fehler von

$$\left|x - rd(x)\right| \leq 0.\underbrace{00...000}_{n \text{ Nullen}}5 \cdot 10^E = 0.5 \cdot 10^{-n+E}$$

### Übung `r nextExercise()`: {.exercise}

Runden Sie bitte die folgenden Zahlen $x_1$ bis $x_4$ auf eine Maschinenzahl in jeweils $n$-stelliger Gleitpunktarithmetik.

Gegeben sind die folgenden Zahlen:

$$
    x_1 = (0.101010101)_2 \cdot 2^3, \quad 
    x_2 = (0.11111111) \cdot 2^4, \quad
    x_3 = (0.101010101)_2 \cdot 2^{-3}, \quad
    x_4 = (0.11111111) \cdot 2^{-4} 
$$

A) Geben Sie die Werte von $x_1$ bis $x_4$ an.

B) Runden Sie die Zahlen $x_1$ bis $x_4$ aus eine 5-stellige Gleitpunktzahl und bestimmen Sie den Wert der Rundung.

C) Runden Sie die Zahlen $x_1$ bis $x_4$ aus eine 4-stellige Gleitpunktzahl und bestimmen Sie den Wert der Rundung.

D) Bestimmen Sie jeweils den absoluten und relativen Fehler der Rundungen und B) und C).


### Maschinengenauigkeit

Für eine Rundung $rd(x)$ eines Wertes $x$ in $n$-stelliger Gleitpunktarithmetik hängt der verbundene sogenannte [absoluter Rundungsfehler]{.cstrong}

$$\left| x - rd(x) \right| \leq \frac{B^{E-n}}{2}$$

noch vom Exponenten $E$ von $x$ ab.

Der [relative Rundungsfehler]{.cstrong} dagegen ist

::: {.footnotesize}
$$\left| \frac{x -\tilde{x}}{x}\right| 
   \leq \left| x -\tilde{x}\right| \cdot \frac{1}{\left|{x}\right|}
   \leq \frac{B^{E-n}}{2} \cdot \frac{1}{|(0.z_1z_2\dots z_n)| \cdot B^E}
   = \frac{B^{-n}}{2} \cdot \frac{B}{|(0.z_1z_2\dots z_n)| \cdot B }
   \leq \frac{B^{-n}}{2} \cdot \frac{B}{1}
   \leq \frac{B^{-n+1}}2 $$
:::

durch den $eps = \frac{B^{1-n}}2$ nach oben beschränkt.  

Der Wert $eps$ wird auch [Maschinengenauigkeit]{.cstrong} genannt. Es gilt damit:

$$rd(x) = (1 + \epsilon)\cdot x \text{ mit } |\epsilon| < eps$$


### Korrektheit gerundeter Gleitpunktzahlen

Die Machinenzahlen $\mathbf{M}$ sind bezüglich der elementaren arithmetischen
Operationen (Addition, Subtraktion, Multiplikation und Division) nicht
abgeschlossen (selbst wenn wir für die Exponenten beliebige Werte erlauben).

**Beispiele:**

- Die Zahl $x = 0.11 \cdot 10^1$ ist eine Gleipunktzahl zur Basis 10 mit Mantissenlänge 2, während $x \cdot x = 0.121 \cdot 10^1$  eine dreistellige Mantissenlänge hat.

- Im IEEE-Single Format sind $1$ und $2^{-24}$ beides Maschinenzahlen, deren Summe $1+2^{-24}$ hingegen nicht.


### Auswirkungen auf die Rechnerarithmetik

Die arithmetischen Grundoperationen $+, -,  \cdot, /$ werden auf Rechenanlagen durch entsprechende *Maschinenoperationen* $+_M, -_M, \cdot_M, /_M$ ersetzt, die Maschinenzahlen in Maschinenzahlen überführen.

Für ein $\bot \in \{+, -, \cdot, /\}$, zwei reelle Zahlen $x$ und $y$ und zwei Machinenzahlen $\tilde{x}=rd(x)$ und $\tilde{y}=rd(y)$ gilt daher, falls weder Unter- noch Überläufe eintreten:

$$\tilde{x} \bot_M \tilde{y} = rd(x \bot y) = (x \bot y)\cdot(1+\epsilon), \qquad  |\epsilon| < eps$$

**Auf dieser Annahme fußt der Großteil moderner Rundungsfehleranalyse!**

*Insbesondere gilt:*

$$\tilde{x} +_M \tilde{y} = \tilde{x}, \qquad  \text{ für } |y| \leq \frac{|x|}{B} \cdot eps$$


### Offene Übung `r nextExercise()`: Maschinengenauigkeit {.exercise .fragile}

Schreiben Sie ein Programm, welches die *Maschinengenauigkeit* **eps** berechnet. 

[Tipp:]{.cemph} Nutzen Sie die Formel ($B=2$):

$$\tilde{x} +_M \tilde{y} = \tilde{x}, \qquad  \text{ für } |y| \leq \frac{|x|}{B} \cdot eps$$

mit $x=1$ und variieren Sie $y$ geschickt.


```{r include=FALSE}
eps = 1
while ((1+eps) != 1 ) {
  eps <- eps / 2
}
eps
```

\begin{verbbox}
eps = 1
while ((1+eps) != 1 ) {
  eps <- eps / 2
}
eps
\end{verbbox}

:::::: {.notes}

Eine mögliche Lösung könnte wie folgt aussehen:

\theverbbox

Als Ergebnis würde man $eps=`r eps`$ erhalten.

::::::


### Übung `r nextExercise()`: Die Numerische Null {.exercise type=A-B-C-D-E answer=B}

Wegen

$$((1/x)/10+1)*x-x = \left(\frac{\frac{1}{x}}{10}+1\right)\cdot x - x 
                   = \frac{\frac{1}{x}}{10}\cdot x + x -x 
                   = \frac{1}{10}$$

gilt mathematisch: `foo(1)`  $= 0.1$!

Wie würden Sie diese Gleichheit in einem (R-)Programm am sinnvollsten abfragen:

A.  `foo(1) = 0.1`
B.  `foo(1) == 0.1`
C.  `abs(foo(1) - 0.1) = 0`
D.  `abs(foo(1) - 0.1) == 0`
E.  `abs(foo(1) - 0.1) < eps`


::: {.notes}
***E*** ist richtig. Möchte man in R auf Gleichheit prüfen (abfragen), so sind zwei Gleichheitszeichen nötig: `==`, da ein Gleichheiszeichen (`=`) für Zuweisungen eingesetzt wird. Daher sind die Antworten mit `=` falsch.

B und D prüfen formal korrekt auf Gleichheit. E hat aber den Vorteil, dass nicht nur zurückgegeben wird, ob Gleichheit vorliegt, sondern ob der Unterschied kleiner als die Maschinengenauigkeit *eps* ist.



Tipp: Probieren Sie: `abs(foo(1) - 0.1)`.
:::


### Rechenarithmetik

- Jede einzelne Operation ($+$,$-$,$\cdot$,$\ldots$) wird auf $n+1$ Stellen gerechnet und dann wird gerundet. Erst im Anschluss wird die nächste Operation durchgeführt

- Das Ergebnis einer Kette von Operationen ist das Ergebnis einer Kette von Rundungen –- nicht erst das Ergebnis ist gerundet!
Bei der Addition müssen erst die Exponenten verglichen und ggfs. angepasst werden, dann können die Mantissen addiert werden. Danach wird ggfs. normalisiert

- Bei der Multiplikation werden die Exponenten addiert und die Mantissen multipliziert. Danach wird ggfs. normalisiert


### Beispiel: Rechenarithmetik

Addition in n=3-stelliger Gleitpunktarithmetik im Dezimalsystem:
	
$$
    \begin{aligned}
        x = 1590 &= 0.159 \cdot 10^4; y = 4 = 0.4\cdot 10^1; z = 4 = 0.4 \cdot 10^1 \\
        x + y    &= 0.159 \cdot 10^4 + 0.4\cdot 10^1 = 0.159 \cdot 10^4 + 0.0004\cdot 10^4 \\
                 &= 0.1594 \cdot 10^4 \approx 0.159 \cdot 10^4 \\
                 &\approx 1590 \\
        (x+y)+z  &= 0.159 \cdot 10^4 + 0.4\cdot 10^1 = 0.159 \cdot 10^4 + 0.0004\cdot 10^4 \\
                 &= 0.1594 \cdot 10^4 \approx 0.159 \cdot 10^4 \\
                 &\approx 1590 \\
        x+(y+z)  &= 0.159 \cdot 10^4 + 0.8\cdot 10^1 = 0.159 \cdot 10^4 + 0.0008\cdot 10^4 \\
                 &= 0.1598 \cdot 10^4 \approx 0.160 \cdot 10^4 \\
                 &\approx 1600 \\
    \end{aligned}
$$

Beachte: Die Reihenfolge der Terme spielt eine Rolle in der Gleitpunktarithmetik (Assoziativität der Additivität ist verloren)!

### Übung `r nextExercise()`:  {.exercise}

Gegeben sind die drei Werte:

$$
    \begin{aligned}
        x_1 &= 123\,454\,000\,000 \text{ Euro} \\
        x_2 &= 123\,446\,000\,000 \text{ Euro} \\
        x_3 &= 123\,435\,000\,000 \text{ Euro} \\
    \end{aligned}
$$

Berechnen Sie in 5-stelliger dezimaler Gleitpunktarithmetik!

- $rd(\tilde{x}_1 -_M \tilde{x}_2)$
- $rd(\tilde{x}_1 -_M \tilde{x}_3)$

::: {.notes}
$$
    \begin{aligned}
        rd(\tilde{x}_1 -_M \tilde{x}_2)   &= 0.123454 \cdot 10^{12} - 0.123446 \cdot 10^{12} \\ 
                                        &= 0.12345 \cdot 10^{12} - 0.12345 \cdot 10^{12} \\
                                        &= 0
    \end{aligned}
$$
$$
    \begin{aligned}
        rd(\tilde{x}_1 -_M \tilde{x}_3)   &= 0.123454 \cdot 10^{12} - 0.123435 \cdot 10^{12} \\
                        &= 0.12345 \cdot 10^{12} - 0.12344 \cdot 10^{12}\\
                        &= 0.00001 \cdot 10^{12} \\
                    &= 0.1 \cdot 10^{8}\\
                    &= 10\,000\,000
     \end{aligned}
$$                  
:::

<!--

### Fehler bei arithmetischen Operationen / Auslöschung

Es sei $\tilde{x} = rd(x) = (1+e_x)\cdot x$ und $\tilde{y} = rd(y) = (1+e_y)\cdot y$.

- *Addition*:
    - absoluter Fehler: $\tilde{x} + \tilde{y} = x + y - e_x \cdot x - e_y \cdot y$
    - relativer Fehler: $\displaystyle \frac{x+y- (\tilde{x}+\tilde{y})}{x + y} = \frac{x}{x+y}\cdot e_x + \frac{y}{x+y}\cdot e_y$
    
- *Multiplikation*:
    - absoluter Fehler: $\tilde{x} \cdot \tilde{y} = (1-e_x-e_y+ e_x \cdot e_y) \cdot xy$
    - relativer Fehler: $\displaystyle \frac{x \cdot y- (\tilde{x} \cdot \tilde{y})}{x \cdot y} = e_x+e_y - e_x \cdot e_y$

Addition ist numerisch fehleranfälliger als Multiplikation: Hoher relativer Fehler bei Subtraktion in etwa gleich großer Zahlen (**Auslöschung**)

### Fehlerfortpflanzung bei Funktionsauswertung
-->


## Numerische Stabilität und Fehleranalyse

### Numerische Stabilität und Fehleranalyse

Beim Auswerten einer Funktion $f$ an der (z.B. gerundeten) Stelle $\tilde{x}$ anstatt an der Stelle $x$ wirkt sich dieser Fehler natürlich auch auf den Funktionswert aus. 

Wird mit diesen (fehlerhaften) Funktionswert weitergerechnet wirkt sich dieser Fehler natürlich auch dort aus, man spricht von **Fehlerfortpflanzung**

Je nach Beschaffenheit der zugrundeliegenden Funktionen kann das Ergebnis mehr oder weniger stark fehlerbehaftet sein.


### Vorwärts- und Rückwärtsfehler

Betrachten wir eine Funktion $f(x)$ auf den reellen Zahlen. Berechnet man nun in normaler Arithmetik $y=f(x)$, so erhält man das exakte Ergebnis für $y$. Nutzt man einen Rechner, so erhält man i.d.R.
$\tilde{y}=rd(f(\tilde{x}))$,  das in Gleitpunktarithmetik berechnete Ergebnis der Funktion $y=f(x)$ ($\tilde{x}=rd(x)$).

Wie beurteilt man die Qualität von $\tilde{y}$?

- [(Relativer) Vorwärtsfehler]{.cstrong}: $\left| \frac{y-\tilde{y}}{y}\right|$
- [(Relativer) Rückwärtsfehler]{.cstrong}: $\left| \frac{x-\tilde{x}}{x}\right|$, dabei sei $\tilde{x}$ der (ein) Eingabewert, welches bei rundungsfreier Rechnung zu $\tilde{y}=f(\tilde{x})$ führt. (Hierbei interpretieren wir Rundungsfehler als Datenfehler.)

Wir versuchen nun den Vorwärtsfehler durch den Rückwärtsfehler abzuschätzen:

$$
\text{Faustregel:}\quad \text{Vorwärtsfehler} \leq \text{Konditionszahl} \cdot \text{Rückwärtsfehler}
$$


### (rel. und abs.) Konditionszahl

Wir möchten in einem (gegebenen) Intervall $I$ den absoluten bzw. relativen Fehler der Funktion (Vorwärtsfehler) mit Hilfe einer Konstanten und dem absoluten bzw. relativen Fehler der Eingabewerte (Rückwärtsfehler) abschätzen, so dass wir eine obere Schranke den den jeweiligen Fehler angeben können.

Wir nennen $M$ eine [absolute Konditionszahl]{.cstrong}, falls gilt:

$$
|f(x) - f(\tilde{x})| \leq M \cdot |x-\tilde{x}|
$$

Wir nennen $K$ eine [relative Konditionszahl]{.cstrong}, falls gilt:

$$
\left|\frac{f(x)-f(\tilde{x})}{f(x)}\right| \leq K \cdot \left|\frac{x-\tilde{x}}{x}\right|
$$

Einmal bestimmt können wir so im Intervall die Fehler abschätzen, ohne die Funktionen explizit auszuwerten.


### Abschätzung und Schätzung des Fehlers bei Funktionsauswertungen

::: {.small}
Es gelten folgende Schranken (Abschätzungen) und Schätzungen^[Abschätzung: gesicherte Aussage; Schätung: ungefähre Aussage] für den Fehler bei Funktionsauswertungen:

- Absoluter Fehler:
$$
    \begin{aligned}
     | f(x) - f(\tilde{x}) | &\leq M \cdot |x - \tilde{x}| \, \text{ mit } M = \max\limits_{x_0 \in I} |f'(x_0)| \\
     | f(x) - f(\tilde{x}) | &\approx |f'(\tilde{x})|\cdot |x - \tilde{x}|\\
    \end{aligned}
$$


- Relativer Fehler:
$$
    \begin{aligned}
     \left| \frac{f(x) - f(\tilde{x})}{f(x)} \right| &\leq \underbrace{M \cdot \frac{\max\limits_{x_0 \in I} |x_0| }{\min\limits_{x_0 \in I} |f(x_0)|}}_{=\text{rel. Konditionszahl} \cdot 1/|x|} \cdot |x - \tilde{x}| \, \text{ mit } M = \max\limits_{x_0 \in I} |f'(x_0)| \\
     \left| \frac{f(x) - f(\tilde{x})}{f(x)} \right|  &\approx {|f'(\tilde{x})|\cdot \frac{|\tilde{x}|}{|f(\tilde{x})|}} \cdot |x - \tilde{x}|\\
    \end{aligned}
$$

wobei $I$ ein Intervall ist, das sowohl $x$ als auch $\tilde{x}$ enthält.

:::


### Beispiel Fehlerfortpflanzung

Es soll das Fehlerfortpflanzungverhalten der Funktion $f(x) = x^2 - 100$ an der Stelle $x=11.1$, $\tilde{x} = 11$, $I=[10.5, 11.5]$ untersucht werden:

- Für den absoluten Fehler gilt, wegen $M = \max\limits_{x_0 \in I} |f'(x_0)| = \max\limits_{x_0 \in I} |2 \cdot x_0| = 2 \cdot 11.5 = 23$:
$$
    \begin{aligned}
        | f(x) - f(\tilde{x}) | &\leq 23 \cdot |11.1 - 11|  = 23 \cdot 0.1 = 2.3 \\
        | f(x) - f(\tilde{x}) | &\approx |f'(\tilde{x})|\cdot |x - \tilde{x}| = 22 \cdot 0.1 = 2.2 \\
    \end{aligned}
$$


- Für den relativen Fehler gilt:
$$
    \begin{aligned}
      \left| \frac{f(x) - f(\tilde{x})}{f(x)} \right|  &\leq 23 \cdot \frac{11.5}{10.25} \cdot 0.1 = 2.580488 \\
      \left| \frac{f(x) - f(\tilde{x})}{f(x)} \right| &\approx |f'(\tilde{x})|\cdot \frac{|\tilde{x}|}{|f(\tilde{x})|} \cdot |x - \tilde{x}| = 22 \cdot \frac{11}{21} \cdot 0.1 = 1.152381 \\
    \end{aligned}
$$


### Übung `r nextExercise()`:  Fehlerfortpflanzung {.exercise}

Gegeben sei die Funktion $f(x) = \sqrt{x}$, $x = 0.011$ und $\tilde{x}=0.01$.

a) Berechnen Sie den wahren absoluten und relativen Fehler für $x$.
b) Geben Sie eine Schätzung für den absoluten und relativen Fehler für $f(x)$ an.
c) Geben Sie ein Abschätzung (obere Schranke) für den absoluten und relativen Fehler von $f(x)$ im Intervall $I = [\tilde{x}, x]$ an.
d) Bestimmen Sie die (relative) Konditionszahl $K$.

```{r echo=FALSE}
library(mosaicCalc)
x <- 0.011
x_tilde <- 0.01
absFehler <- abs(x - x_tilde)
relFehler <- absFehler / abs(x)
f <- makeFun(sqrt(x) ~ x)
df <- D(f(x) ~ x)
M <- abs(df(x)) # Da monoton fallend!
```

::: {.notes}

a) Absoluter Fehler: $`r absFehler`$

   Relativer Fehler: $`r relFehler`$
   
b) Absoluter Fehler: $| f(x) - f(\tilde{x}) | \approx |f'(\tilde{x})| \cdot |x - \tilde{x}| = `r abs(df(x_tilde))` \cdot `r absFehler` = `r abs(df(x_tilde)) * absFehler`$

   Relativer Fehler: $\left| \frac{f(x) - f(\tilde{x})}{f(x)} \right| \approx |f'(\tilde{x})|\cdot \frac{|\tilde{x}|}{|f(\tilde{x})|} \cdot |x - \tilde{x}| = `r abs(df(x_tilde))` \cdot `r abs(x_tilde)/abs(f(x_tilde))` \cdot `r absFehler` = `r abs(df(x_tilde)) * abs(x_tilde)/abs(f(x_tilde)) * absFehler`$
   
c) Da $f'$ monoton fallend auf $I=[`r x`; `r x_tilde`]$ gilt $M = \max\limits_{x_0 \in I} |f'(x_0)| = `r M`$ und somit:


    Absoluter Fehler: $| f(x) - f(\tilde{x}) | \leq M \cdot |x - \tilde{x}| = `r M` \cdot `r absFehler` = `r M * absFehler`$

   Relativer Fehler: $\left| \frac{f(x) - f(\tilde{x})}{f(x)} \right| \leq M \cdot \frac{|\tilde{x}|}{|f(\tilde{x})|} \cdot |x - \tilde{x}| = `r M` \cdot `r abs(x_tilde)/abs(f(x_tilde))` \cdot `r absFehler` = `r M * abs(x_tilde)/abs(f(x_tilde)) * absFehler`$
   
d) $K = M \cdot \frac{|\tilde{x}|}{|f(\tilde{x})|} \cdot |x| = `r M` \cdot `r abs(x_tilde)/abs(f(x_tilde))` \cdot `r abs(x)` = `r M  * abs(x_tilde)/abs(f(x_tilde)) * abs(x)`$

:::


### Das wissen sie nun!

- Gleitpunktzahlen setzten sich zusammen aus dem Vorzeichen, der Mantisse und der Basis hoch dem Exponenten. Bei normalisierten Gleitpunktzahlen ist die erste Ziffer der Mantisse ungleich $0$.

- Die Menge der auf einen Rechner darstellbaren Zahlen ist endlich und ungleichmäßig verteilt.

- Bei arithmetischen Operationen wird nach jeder Operation zuerst auf die nächste Maschinenzahl gerundete Auslöschung kann bei der Subtraktion zweier in etwa gleich großer Zahlen auftreten und kann zu einem hohen relativen Fehler führen.

- (Rundungs-)Fehler wirken sich je nach Funktion und Auswertungsstelle unterschiedlich aus. Dabei können relative und absolute Fehler eventuell verstärkt werden.


### Hausaufgabe {.fragile}

Untersuchen Sie die folgenden Folgen auf Konvergenz in dem Sie die Folge
$(a_n)$ mit Hilfe eines Computerprogramms oder einer Tabellenkalkulation 
an den Stellen $a_{80}$ und $a_{100}$ auswerten.

Stellen Sie Vermutungen über den Grenzwert an!

Es sei dazu
\begin{equation*}
	f(x,y) = 108 - \frac{815-\frac{1500}{y}}{x}
\end{equation*}
und die Folge durch
\begin{equation*}
	a_0 = 4;\quad a_1 = 4{,}25;\quad a_{n+1} = f(a_n, a_{n-1})
\end{equation*}
gegeben.


```{r include=FALSE}
f <- function(x,y) 108-((815-1500/y)/x)

a <- c(4, 4.25)
for(i in 1:100) {
    a <- c(a, f(a[i], a[i+1]))
}
```

\begin{verbbox}
f <- function(x, y) 108-((815-1500/y)/x)

a <- c(4, 4.25)
for(i in 1:100) {
    a <- c(a, f(a[i], a[i+1]))
}
\end{verbbox}

::::: {.notes}

Ein Programm in R könnte wie folgt aussehen:

\theverbbox

Es lieftert die Werte a[70]=`r a[70]` und a[100]=`r a[100]` ...

Der Grenzwert aber ist in der Tat 5!

Vgl.: https://scipython.com/blog/mullers-recurrence/


Weiterführende Literatur: 

 - [How Futile are Mindless Assessments of Roundoff in Floating-Point Computation ?](https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf)
 - [What Every Computer Scientist Should Know About Floating-Point Arithmetic](http://perso.ens-lyon.fr/jean-michel.muller/goldberg.pdf)
 
:::::

```{r finish-EinfuehrungInDieNumerik, include=FALSE}
rm(pathToImages)
finalizePart(partname)
```
